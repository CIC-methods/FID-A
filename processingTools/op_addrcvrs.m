% op_addrcvrs.m
% Jamie Near, McGill University 2014.
% 
% USAGE:
% [out,fids_presum,specs_presum,coilcombos]=op_addrcvrs(in,point,mode,coilcombos);
% 
% DESCRIPTION:
% Perform weighted coil recombination for MRS data acquired with a reciever
% coil array.
% 
% INPUTS:
% in            = input spectrum in matlab structure format.
% point         = point of fid to use for phase estimation (optional. Default = 1);
% mode          = Method for estimating the coil weights and phases (optional.  Default = 'w').
%                 -'w' performs amplitude weighting of channels based on the
%                 maximum signal of each coil channel.
%                 -'h' performs amplitude weighting of channels based on the
%                 maximum signal of each coil channel divided by the square of
%                 the noise in each coil channel (as described by Hall et al.
%                 Neuroimage 2014).
%                 -'gls' combines channels using generalized least squares
%                 (GLS) (as described by An et al., 2013, doiï»¿:10.1002/jmri.23941).
% coilcombos	= The predetermined coil phases (in [degrees])and amplitudes 
%                 as generated by the op_getcoilcombos.m function.  If this
%                 argument is provided, the 'point', and 'mode', arguments 
%                 will be ignored.  (Optional.  Default = []).
%
% OUTPUTS:
% out           = Output dataset with coil channels combined.
% fids_presum   = Input data with coil channels in phase (time domain).
% specs_presum  = Input data with coil channels in phase (frequency domain).
% coilcombos    = Structure containing two fields:
%                   ph:  Vector of coil phases (in [degrees]) used for alignment.
%                   sig: Vector of coil weights.
%                   w:   Vector of coil weights used for GLS

         
function [out,fids_presum,specs_presum,coilcombos]=op_addrcvrs(in,point,mode,coilcombos)

if in.flags.addedrcvrs || ~in.dims.coils
    disp('WARNING:  Only one receiver channel found!  Returning input without modification!');
    out=in;
    out.flags.addedrcvrs=1;
    fids_presum=in.fids;
    specs_presum=in.specs;
    coilcombos.ph=0;
    coilcombos.sig=1;
    coilcombos.w=1;
else
    
    %To get best possible SNR, add the averages together (if it hasn't already been done):
    if ~in.flags.averaged
        av=op_averaging(in);
    else
        av=in;
    end
    
    %also, for best results, we will combine all subspectra:
    if nargin<4
        if in.flags.isFourSteps
            av=op_fourStepCombine(av);
        end
        if in.dims.subSpecs>0
            av=op_combinesubspecs(av,'summ');
        end
        if nargin<3
            mode = 'w';
            if nargin<2
                point=1;
            end
        end
    end
    avfids=av.fids;

    if strcmp(mode,'gls') && nargin==4
        noisepts=false(1,in.sz(in.dims.t));
        noisepts(ceil(0.75*in.sz(in.dims.t)):end)=true;
        if in.subspecs>1
            noisepts=repmat(noisepts,[1 in.sz(in.dims.averages)*in.sz(in.dims.subSpecs)]);
            tmpfids=reshape(in.fids,[in.sz(in.dims.coils) in.sz(in.dims.t)*in.sz(in.dims.averages)*in.sz(in.dims.subSpecs)]);
        else
            noisepts=repmat(noisepts,[1 in.sz(in.dims.averages)]);
            tmpfids=reshape(in.fids,[in.sz(in.dims.coils) in.sz(in.dims.t)*in.sz(in.dims.averages)]);
        end
        e=tmpfids(:,noisepts);
        Psi=e*e';
        coilcombos.w=(coilcombos.sig'*(Psi\coilcombos.sig))^-1*coilcombos.sig'/Psi;
        coilcombos.w=coilcombos.w.';
    end
    
    %initialize phase matrix and the amplitude maxtrix that are the size of nPoints x Coils
    %ph=ones(in.sz(in.dims.t),in.sz(in.dims.coils));
    %sig=ones(in.sz(in.dims.t),in.sz(in.dims.coils));
    
    %now start finding the relative phases between the channels and populate
    %the ph matrix
    [phs,sigs,wgts]=deal(zeros(1,in.sz(in.dims.coils)));
    for n=1:in.sz(in.dims.coils)
        if nargin<4
            %ph(:,n)=phase(avfids(point,n,1,1))*ph(:,n);
            phs(n)=phase(avfids(point,n,1,1))*180/pi;  %in [degrees]
            switch mode
                case 'w'
                    %sig(:,n)=abs(avfids(point,n,1,1))*sig(:,n);
                    sigs(n)=abs(avfids(point,n,1,1));
                case 'h'
                    S=max(abs(avfids(:,n,1,1)));
                    N=std(avfids(end-100:end,n,1,1));
                    %sig(:,n)=(S/(N.^2))*sig(:,n);
                    sigs(n)=(S/(N.^2));
            end
        else
            %ph(:,n)=coilcombos.ph(n)*ph(:,n);
            phs(n)=coilcombos.ph(n);
            sigs(n)=coilcombos.sig(n);
            if strcmp(mode,'gls')
                wgts(n)=coilcombos.w(n);
            end
        end
    end
    
    %now replicate the phase matrix to equal the size of the original matrix:
    % replicate=in.sz;
    % replicate(1)=1;
    % replicate(in.dims.coils)=1;
    % ph=repmat(ph,replicate);
    % sig=repmat(sig,replicate);
    if ~strcmp(mode,'gls')
        sigs=sigs/norm(sigs(:));
    end
    
    ph=ones(in.sz);
    sig=ones(in.sz);
    w=ones(in.sz);
    
    switch in.dims.coils
        case 1
            for n=1:in.sz(1)
                ph(n,:)=phs(n)*ph(n,:);
                sig(n,:)=sigs(n)*sig(n,:);
                if strcmp(mode,'gls')
                    w(n,:)=wgts(n)*w(n,:);
                end
            end
        case 2
            for n=1:in.sz(2)
                ph(:,n,:)=phs(n)*ph(:,n,:);
                sig(:,n,:)=sigs(n)*sig(:,n,:);
                if strcmp(mode,'gls')
                    w(:,n,:)=wgts(n)*w(:,n,:);
                end
            end
        case 3
            for n=1:in.sz(3)
                ph(:,:,n,:)=phs(n)*ph(:,:,n,:);
                sig(:,:,n,:)=sigs(n)*sig(:,:,n,:);
                if strcmp(mode,'gls')
                    w(:,:,n,:)=wgts(n)*w(:,:,n,:);
                end
            end
        case 4
            for n=1:in.sz(4)
                ph(:,:,:,n,:)=phs(n)*ph(:,:,:,n,:);
                sig(:,:,:,n,:)=sigs(n)*sig(:,:,:,n,:);
                if strcmp(mode,'gls')
                    w(:,:,:,n,:)=wgts(n)*w(:,:,:,n,:);
                end
            end
        case 5
            for n=1:in.sz(5)
                ph(:,:,:,:,n)=phs(n)*ph(:,:,:,:,n);
                sig(:,:,:,:,n)=sigs(n)*sig(:,:,:,:,n);
                if strcmp(mode,'gls')
                    w(:,:,:,:,n)=wgts(n)*w(:,:,:,:,n);
                end
            end
    end
    
    
    %now apply the phases by multiplying the data by exp(-1i*ph);
    if ~strcmp(mode,'gls')
        fids=in.fids.*exp(-1i*ph*pi/180);
    else
        fids=in.fids;
    end
    fids_presum=fids;
    specs_presum=fftshift(ifft(fids,[],in.dims.t),in.dims.t);
    
    %Apply the amplitude factors by multiplying the data by amp;
    if any(strcmp(mode,{'w','h'}))
        fids=fids.*sig;
    elseif strcmp(mode,'gls')
        fids=w.*fids;
    end
    
    %Make the coilcombos structure:
    coilcombos.ph=phs;
    coilcombos.sig=sigs;
    coilcombos.w=wgts;
    
    %now sum along coils dimension
    fids=sum(fids,in.dims.coils);
    fids=squeeze(fids);
    
    %re-calculate Specs using fft
    specs=fftshift(ifft(fids,[],in.dims.t),in.dims.t);
    
    %change the dims variables
    if in.dims.t>in.dims.coils
        dims.t=in.dims.t-1;
    else
        dims.t=in.dims.t;
    end
    dims.coils=0;
    if in.dims.averages>in.dims.coils
        dims.averages=in.dims.averages-1;
    else
        dims.averages=in.dims.averages;
    end
    if in.dims.subSpecs>in.dims.coils
        dims.subSpecs=in.dims.subSpecs-1;
    else
        dims.subSpecs=in.dims.subSpecs;
    end
    if in.dims.extras>in.dims.coils
        dims.extras=in.dims.extras-1;
    else
        dims.extras=in.dims.extras;
    end
    
    %re-calculate the sz variable
    sz=size(fids);
    
    %FILLING IN DATA STRUCTURE
    out=in;
    out.fids=fids;
    out.specs=specs;
    out.sz=sz;
    out.dims=dims;
    
    %FILLING IN THE FLAGS
    out.flags=in.flags;
    out.flags.writtentostruct=1;
    out.flags.addedrcvrs=1;
    
end

end




